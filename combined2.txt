===== C:\Users\zzzAR\GolandProjects\test_task\create_structure.sh =====
mkdir -p server/{cmd,internal/{config,pow,quotes,server,protocol}}
mkdir -p client/{cmd,internal/{config,pow,client}}
touch server/quotes.json 
===== C:\Users\zzzAR\GolandProjects\test_task\client\Dockerfile =====
FROM golang:1.21-alpine
WORKDIR /app
COPY . .
RUN go mod init client && \
    go mod tidy && \
    go build -o client ./cmd
CMD ["./client"] 
===== C:\Users\zzzAR\GolandProjects\test_task\client\cmd\main.go =====
package main
import (
	"fmt"
	"log"
	"time"
	"client/internal/client"
)
func main() {
	c := client.NewClient(":8080", 4, 30*time.Second)
	quote, err := c.GetQuote()
	if err != nil {
		log.Fatalf("Error getting quote: %v", err)
	}
	fmt.Printf("Received quote: %s\n", quote)
} 
===== C:\Users\zzzAR\GolandProjects\test_task\client\internal\client\client.go =====
package client
import (
    "bufio"
    "fmt"
    "net"
    "strings"
    "time"
    "client/internal/pow"
)
type Client struct {
    address  string
    solver   *pow.Solver
    timeout  time.Duration
}
func NewClient(address string, difficulty int, timeout time.Duration) *Client {
    return &Client{
        address:  address,
        solver:   pow.NewSolver(difficulty),
        timeout:  timeout,
    }
}
func (c *Client) GetQuote() (string, error) {
    conn, err := net.DialTimeout("tcp", c.address, c.timeout)
    if err != nil {
        return "", err
    }
    defer conn.Close()
    conn.SetDeadline(time.Now().Add(c.timeout))
    // Отправляем HELLO
    fmt.Fprintf(conn, "HELLO\n")
    reader := bufio.NewReader(conn)
    // Получаем вызов
    challenge, err := reader.ReadString('\n')
    if err != nil {
        return "", err
    }
    parts := strings.Fields(challenge)
    if len(parts) != 2 || parts[0] != "CHALLENGE" {
        return "", fmt.Errorf("invalid challenge format")
    }
    // Решаем PoW
    solution := c.solver.Solve(parts[1])
    // Отправляем решение
    fmt.Fprintf(conn, "SOLUTION %s\n", solution)
    // Получаем ответ
    response, err := reader.ReadString('\n')
    if err != nil {
        return "", err
    }
    parts = strings.Fields(response)
    if len(parts) < 1 {
        return "", fmt.Errorf("invalid response")
    }
    if parts[0] == "ERROR" {
        return "", fmt.Errorf("solution rejected")
    }
    if parts[0] != "QUOTE" {
        return "", fmt.Errorf("unexpected response")
    }
    return strings.Join(parts[1:], " "), nil
} 
===== C:\Users\zzzAR\GolandProjects\test_task\client\internal\pow\solver.go =====
package pow
import (
	"crypto/sha256"
	"encoding/hex"
	"math/rand"
	"time"
)
type Solver struct {
	difficulty int
}
func NewSolver(difficulty int) *Solver {
	return &Solver{difficulty: difficulty}
}
func (s *Solver) Solve(challenge string) string {
	rand.Seed(time.Now().UnixNano())
	for {
		nonce := make([]byte, 8)
		rand.Read(nonce)
		solution := hex.EncodeToString(nonce)
		combined := challenge + solution
		hash := sha256.Sum256([]byte(combined))
		valid := true
		for i := 0; i < s.difficulty; i++ {
			if hash[i/8]>>(7-(i%8))&1 != 0 {
				valid = false
				break
			}
		}
		if valid {
			return solution
		}
	}
} 
===== C:\Users\zzzAR\GolandProjects\test_task\server\Dockerfile =====
FROM golang:1.21-alpine
WORKDIR /app
COPY . .
RUN go mod init server && \
    go mod tidy && \
    go build -o server ./cmd
EXPOSE 8080
CMD ["./server"] 
===== C:\Users\zzzAR\GolandProjects\test_task\server\quotes.json =====
[
    "Мудрость приходит с опытом, а опыт приходит с ошибками",
    "Лучше один раз увидеть, чем сто раз услышать",
    "Дорогу осилит идущий",
    "Век живи - век учись",
    "Без труда не выловишь и рыбку из пруда"
] 
===== C:\Users\zzzAR\GolandProjects\test_task\server\cmd\main.go =====
package main
import (
	"context"
	"log"
	"os"
	"os/signal"
	"syscall"
	"server/internal/config"
	"server/internal/pow"
	"server/internal/quotes"
	"server/internal/server"
)
func main() {
	cfg := config.NewConfig()
	powService := pow.NewPoW(cfg.PowDifficulty)
	quoteService, err := quotes.NewQuoteService(cfg.QuotesFile)
	if err != nil {
		log.Fatalf("Failed to initialize quote service: %v", err)
	}
	srv := server.NewServer(cfg, powService, quoteService)
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	// Обработка сигналов для graceful shutdown
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		<-sigChan
		cancel()
	}()
	if err := srv.Start(ctx); err != nil {
		log.Fatalf("Server error: %v", err)
	}
} 
===== C:\Users\zzzAR\GolandProjects\test_task\server\internal\config\config.go =====
package config
type Config struct {
    Port            string
    QuotesFile      string
    PowDifficulty   int
    ReadTimeout     int
    WriteTimeout    int
    MaxConnections  int
    ChallengeLength int
}
func NewConfig() *Config {
    return &Config{
        Port:            ":8080",
        QuotesFile:      "quotes.json",
        PowDifficulty:   4,            // количество нулевых битов
        ReadTimeout:     30,           // секунды
        WriteTimeout:    30,           // секунды
        MaxConnections:  100,
        ChallengeLength: 32,
    }
} 
===== C:\Users\zzzAR\GolandProjects\test_task\server\internal\pow\pow.go =====
package pow
import (
    "crypto/sha256"
    "encoding/hex"
    "math/rand"
    "time"
)
type PoW struct {
    difficulty int
}
func NewPoW(difficulty int) *PoW {
    return &PoW{difficulty: difficulty}
}
func (p *PoW) GenerateChallenge(length int) string {
    rand.Seed(time.Now().UnixNano())
    bytes := make([]byte, length)
    rand.Read(bytes)
    return hex.EncodeToString(bytes)
}
func (p *PoW) VerifySolution(challenge, solution string) bool {
    combined := challenge + solution
    hash := sha256.Sum256([]byte(combined))
    // Проверяем, начинается ли хеш с нужного количества нулевых битов
    for i := 0; i < p.difficulty; i++ {
        if hash[i/8]>>(7-(i%8))&1 != 0 {
            return false
        }
    }
    return true
} 
===== C:\Users\zzzAR\GolandProjects\test_task\server\internal\protocol\protocol.go =====
package protocol
const (
    CmdHello     = "HELLO"
    CmdChallenge = "CHALLENGE"
    CmdSolution  = "SOLUTION"
    CmdQuote     = "QUOTE"
    CmdError     = "ERROR"
)
type Message struct {
    Command string
    Payload string
}
func (m *Message) String() string {
    if m.Payload == "" {
        return m.Command
    }
    return m.Command + " " + m.Payload
} 
===== C:\Users\zzzAR\GolandProjects\test_task\server\internal\quotes\quotes.go =====
package quotes
import (
	"encoding/json"
	"math/rand"
	"os"
	"time"
)
type QuoteService struct {
	quotes []string
}
func NewQuoteService(filename string) (*QuoteService, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}
	var quotes []string
	if err := json.Unmarshal(data, &quotes); err != nil {
		return nil, err
	}
	return &QuoteService{quotes: quotes}, nil
}
func (qs *QuoteService) GetRandomQuote() string {
	rand.Seed(time.Now().UnixNano())
	return qs.quotes[rand.Intn(len(qs.quotes))]
} 
===== C:\Users\zzzAR\GolandProjects\test_task\server\internal\server\server.go =====
package server
import (
    "bufio"
    "context"
    "fmt"
    "net"
    "strings"
    "sync"
    "time"
    "server/internal/config"
    "server/internal/pow"
    "server/internal/protocol"
    "server/internal/quotes"
)
type Server struct {
    config       *config.Config
    pow          *pow.PoW
    quoteService *quotes.QuoteService
    listener     net.Listener
    connections  sync.Map
    shutdown     chan struct{}
}
func NewServer(cfg *config.Config, pow *pow.PoW, qs *quotes.QuoteService) *Server {
    return &Server{
        config:       cfg,
        pow:          pow,
        quoteService: qs,
        shutdown:     make(chan struct{}),
    }
}
func (s *Server) Start(ctx context.Context) error {
    var err error
    s.listener, err = net.Listen("tcp", s.config.Port)
    if err != nil {
        return err
    }
    go s.acceptConnections(ctx)
    <-ctx.Done()
    return s.Stop()
}
func (s *Server) Stop() error {
    close(s.shutdown)
    if s.listener != nil {
        return s.listener.Close()
    }
    return nil
}
func (s *Server) acceptConnections(ctx context.Context) {
    var connectionCount int32
    for {
        conn, err := s.listener.Accept()
        if err != nil {
            select {
            case <-s.shutdown:
                return
            default:
                continue
            }
        }
        if connectionCount >= int32(s.config.MaxConnections) {
            conn.Close()
            continue
        }
        connectionCount++
        go s.handleConnection(ctx, conn, &connectionCount)
    }
}
func (s *Server) handleConnection(ctx context.Context, conn net.Conn, count *int32) {
    defer func() {
        conn.Close()
        *count--
    }()
    s.connections.Store(conn.RemoteAddr(), conn)
    defer s.connections.Delete(conn.RemoteAddr())
    reader := bufio.NewReader(conn)
    // Установка таймаутов
    conn.SetReadDeadline(time.Now().Add(time.Duration(s.config.ReadTimeout) * time.Second))
    conn.SetWriteDeadline(time.Now().Add(time.Duration(s.config.WriteTimeout) * time.Second))
    // Ожидаем HELLO
    message, err := reader.ReadString('\n')
    if err != nil || !strings.HasPrefix(message, protocol.CmdHello) {
        return
    }
    // Генерируем и отправляем вызов
    challenge := s.pow.GenerateChallenge(s.config.ChallengeLength)
    fmt.Fprintf(conn, "%s %s\n", protocol.CmdChallenge, challenge)
    // Ожидаем решение
    message, err = reader.ReadString('\n')
    if err != nil {
        return
    }
    parts := strings.Fields(message)
    if len(parts) != 2 || parts[0] != protocol.CmdSolution {
        return
    }
    // Проверяем решение
    if s.pow.VerifySolution(challenge, parts[1]) {
        quote := s.quoteService.GetRandomQuote()
        fmt.Fprintf(conn, "%s %s\n", protocol.CmdQuote, quote)
    } else {
        fmt.Fprintf(conn, "%s\n", protocol.CmdError)
    }
} 
